# Connecting to a backend

## Make a go backend
- `go mod init github.com/harryfpayne/babys-first-infra/services/backend`
- make a `main.go` with a simple "Hello, World!" http server
```go
package main

import "net/http"

func main() {
	http.HandleFunc("/", handler)

	err := http.ListenAndServe(":8080", nil)
	if err != nil {
		panic(err)
	}
}

func handler(w http.ResponseWriter, r *http.Request) {
	w.Write([]byte("Hello, World!"))
}
```
- Put it in a docker image
```dockerfile
FROM golang

WORKDIR /app

COPY go.mod ./
RUN go mod download

COPY *.go ./

# Build
RUN CGO_ENABLED=0 GOOS=linux go build -o /main

EXPOSE 8080

# Run
CMD ["/main"]
```
- Build it `docker build --platform=linux/amd64 -t registry.digitalocean.com/harry/backend .`
- Push it `docker push registry.digitalocean.com/harry/backend`
- Make a deployment and service for it
- Instead of the normal LoadBalancer, we'll make a ClusterIp service
- https://www.baeldung.com/ops/kubernetes-service-types
```terraform
resource "kubernetes_deployment" "backend" {
  metadata {
    name = "backend"
    labels = {
      app = "backend"
    }
  }

  spec {
    replicas = 1
    selector {
      match_labels = {
        app = "backend"
      }
    }
    template {
      metadata {
        labels = {
          app = "backend"
        }
      }
      spec {
        image_pull_secrets {
          name = kubernetes_secret.docker_credentials.metadata[0].name
        }

        container {
          image = "${digitalocean_container_registry.container_registry.endpoint}/backend"
          name  = "example"

          port {
            container_port = 8080
          }
        }
      }
    }
  }
}

resource "kubernetes_service" "backend" {
  metadata {
    name = "backend"
  }
  spec {
    selector = {
      app = kubernetes_deployment.backend.metadata[0].labels.app
    }
    port {
      port        = 80
      target_port = 8080
    }
    type = "ClusterIP"
  }
}
```
- We'll now setup the frontend to talk to it
- I'm going to use the internal cluster DNS entry, you can read about it here:
- https://yuminlee2.medium.com/kubernetes-dns-bdca7b7cb868#:~:text=In%20Kubernetes%2C%20DNS%20names%20are%20assigned%20to%20Pods%20and%20Services,can%20be%20customized%20if%20required.
- I checked the DNS name of the backend by:
  - `k exec -it frontend-7556955cc4-pn477 sh` to 'ssh' into it
  - `nslookup backend` gives dns entries containing `backend` for us 
  - the DNS entry is`backend.default.svc.cluster.local`
- We'll pass this as an environment variable to the frontend
```terraform
resource "kubernetes_deployment" "frontend" {
  metadata {
    name = "frontend"
    labels = {
      app = "frontend"
    }
  }

  spec {
    replicas = 1
    selector {
      match_labels = {
        app = "frontend"
      }
    }
    template {
      metadata {
        labels = {
          app = "frontend"
        }
      }
      spec {
        image_pull_secrets {
          name = kubernetes_secret.docker_credentials.metadata[0].name
        }

        container {
          image = "${digitalocean_container_registry.container_registry.endpoint}/frontend"
          name  = "example"

          port {
            container_port = 3000
          }

          env {
            name = "API_URL"
            value = "backend.default.svc.cluster.local"
          }
        }
      }
    }
  }
}
```
- I'll now add an api route to talk to the backend, I'm modifying the default `hello.ts` one
```typescript
import type { NextApiRequest, NextApiResponse } from "next";

export default async function handler(
        req: NextApiRequest,
        res: NextApiResponse<any>,
) {
  const url = process.env.API_URL
  console.log(url)
  const response = await fetch(`http://${url}`)
          .then(r => r.text())
          .catch(e => console.error(e))
  res.status(200).json({ response: response });
}
```
- Rebuild the docker image for the frontend and push it
- We didn't tag a specific version of the docker image before so the frontend probably won't change
- Add an image pull policy so kube always fetches the latest image
```terraform
image_pull_policy = "Always"
```
- We're now communicating with the backend from inside the cluster!